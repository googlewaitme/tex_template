\section{Цель работы}
Ознакомиться с парадигмами вычислительной математики, на практике отработать метод Герона, реализовав программу на языке программирования с++.
\section{Теория}

Итерационная формула Герона имеет вид
\begin{eqnarray}
 x_{n+1} &=& \frac{1}{2} \left(x_{n} + \frac{a}{x_{n}}\right)
\end{eqnarray}
где a — фиксированное положительное число, а $ x_{1} $ — любое положительное число.

Итерационная формула задаёт убывающую (начиная со 2-го элемента) последовательность, которая при любом выборе $ x_{1} $ быстро сходится к величине $ \sqrt{a} $ (квадратный корень из числа), то есть 
\begin{eqnarray}
	\lim _{n\rightarrow \infty } x_{n}={\sqrt {a}}
\end{eqnarray}

Эту формулу можно получить, применяя метод Ньютона к решению уравнения $ a-x^{2}=0 $
\section{Ход работы}
Так как мат.модель была разобрана в блоке теория, я начал писать исходный код. В первую очередь я создал константу, отвечающую за точность вычислений - EPS. Для того, чтобы понять, что был получен ответ с необходимой точностью, в программе сравниваются $ x^2 - a > EPS $, если ответ получен - программа завершается.

Параметры $ x_{0} $ и а были реализованы как вводимые пользователем.

\lstinputlisting[language=c++, caption={Исходный код. main.cpp}]{main.cpp}

\lstinputlisting[language=python, caption={Реализация на python}]{main.py}

\section{Выводы}
\begin{itemize}
	\item При помощи метода Ньютона нелинейная задача была приведена к итерационной, линейной задаче
	\item Алгоритм включил в себя новый параметр, который отвечает за номер итерации
	\item Неточная реализация вычислительного алгоритма вызвана ошибками округления, но никак не математической моделью
	\item Реализация на языке программирования C++ показала хорошие результаты по скорости решения и качеству ответа, но ограничена размерами типа данных double.
	\item Реализация на python, даёт правильные ответы при любой точности, благодаря реализации длинной арифметики, но работает медленнее.
\end{itemize}